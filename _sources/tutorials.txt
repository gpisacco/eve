.. _tutorials:

Tutorials
=========

Account Management
------------------
.. admonition:: Please note

    This tutorial assumes that the :ref:`quickstart` and the :ref:`auth` guides
    have been read already.

Except the relatively rare occurence of open (and generally read-only) public
APIs, most services are only accessible to authenticated users.  A common
pattern is that users create their account on a website or with a mobile
application.  Once they have an account they are allowed to consume one or more
APIs. This is the model followed by most social networks and service providers
(Twitter, Facebook, Netflix, etc.) So how do you, the service provider, manage
to create, edit and delete accounts while using the same API that is being
consumed by the accounts themselves?

In the following paragraphs we'll see a couple of possible Account Management
implementations, both making intensive use of a host of Eve features such as
:ref:`endpointsec`, :ref:`roleaccess`, :ref:`user-restricted`,
:ref:`eventhooks`. 

We assume that SSL/TLS is enabled, which means that the our transport layer is
encrypted, making both :ref:`basic` and :ref:`token` valid options to secure API
endpoints. 

Our tasks are:

1. Make an endpoint available for all account management activities
   (``/accounts/``). 
2. Secure the endpoint, so that it is only accessible to clients
   that we control: our own website, mobile apps with account
   management capabilities, etc.
3. Make sure that all other API endpoints are only accessible to authenticated
   accounts created, by means of the above mentioned endpoint.
4. Allow authenticated users to only access resources created by themselves.

Let's say we're upgrading the API we defined in the :ref:`quickstart` tutorial.

1. the ``/accounts/`` endpoint
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The account management endpoint is no different than any other API endpoint.
It is just a matter of declaring it in our settings file. Let's declare the
resource schema first.

::

        schema =  {
            'username': {
                'type': 'string',
                'minlength': 5,
                'maxlength': 25,
                'required': True,
                'unique': True,
                },
            'password': {
                'type': 'string',
                'minlength': 5,
                'maxlength': 10,
                'required': True,
            },
        },

Then, let's define the endpoint.

::

    accounts = {
        # the standard account entry point is defined as
        # '/accounts/<ObjectId>/'. We define  an additional read-only entry 
        # point accessible at '/accounts/<username>/'. 
        'additional_lookup': {
            'url': '[\w]+',
            'field': 'username',
        },

        # We also disable endpoint caching as we don't want client apps to
        # cache account data.
        'cache_control': '',
        'cache_expires': 0,

        # Finally, let's add the schema definition for this endpoint.
        'schema': schema,
    }

We defined an additional read-only entry point at ``/accounts/<username>/``.
This isn't really needed, but it can come in handy to easily verify if
a username has been taken already, or to retrieve an account without knowing
its ``ObjectId`` beforehand. Of course, both informations can also be achieved
by querying the resource endpoint (``/accounts/?where={"username":
"johndoe"}``), but then we would need to parse the response payload, whereas by
hitting our new endpoint with a GET request we will obtain the bare account
data, or a ``404 Not Found`` if the account does not exist.

Once the endpoint has been configured we need to add it to the API domain:

::

    DOMAIN['accounts'] = accounts


2. Securing the ``/accounts/`` endpoint
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2a. Hard-coding our way in
''''''''''''''''''''''''''
Securing the endpoint can be achieved by allowing only well known `superusers`
to operate on it. Our authentication class, which is defined in the launch
script, can be hard-coded to handle the case:

.. code-block:: python

    import bcrypt
    from eve import Eve
    from eve.auth import BasicAuth


    class BCryptAuth(BasicAuth):
        def check_auth(self, username, password, allowed_roles, resource):
            if resource = 'accounts':
                return username == 'superuser' and password = 'password'
            else:
                # use Eve's own db driver; no additional connections/resources are used
                accounts = app.data.driver.db['accounts']
                account = accounts.find_one({'username': username})
                return account and \
                    bcrypt.hashpw(password, account['password']) == account['password']


    if __name__ == '__main__':
        app = Eve(auth=BCryptAuth)
        app.run()

Thus, only the ``superuser`` account will be allowed to consume the
``accounts`` endpoint, while standard authentication logic will be applied to
all other endpoints. Our mobile app (say) will add accounts by hitting the
endpoint with simple POST requests, of course authenticating itself as
a `superuser` by means of the `Authorization` header. The script assumes that
stored passwords are encrypted with `bcrypt` (storing passwords as plain text is
*never* a good idea). See :ref:`basic` for an alternative, faster but less
secure SHA1/MAC example. 

2b. User Roles Access Control
'''''''''''''''''''''''''''''
Hard-coding usernames and passwords might very well achieve our goal but it is
hardly the best approach that we can take here. What if another `superurser`
account needs access to the endpoint? Updating the script every time we have
users does not seem appropriate (it isn't).  Fortunately the :ref:`roleaccess`
feature can help us here. You see where we are going with this. The idea is
that only accounts with `superuser` and `admin` roles will be granted access to
the endpoint.

Let's start by updating our resource schema.

::

        schema =  {
            'username': {
                'type': 'string',
                'minlength': 5,
                'maxlength': 25,
                'required': True,
                },
            'password': {
                'type': 'string',
                'minlength': 5,
                'maxlength': 10,
                'required': True,
            },
            'roles': {
                'type': 'list',
                'allowed': ['user', 'superuser', 'admin'],
                'required': True,
            }
        },

We just added a new ``roles`` field which is a required list. From now on, one
or more roles will have to be assigned on account creation. 

Now we need to restrict endpoint access to `superuser` and `admin` accounts
only, so let's update the endpoint definition accordingly.

::

    accounts = {
        # the standard account entry point is defined as
        # '/accounts/<ObjectId>/'. We define  an additional read-only entry 
        # point accessible at '/accounts/<username>/'. 
        'additional_lookup': {
            'url': '[\w]+',
            'field': 'username',
        },

        # We also disable endpoint caching as we don't want client apps to
        # cache account data.
        'cache_control': '',
        'cache_expires': 0,

        # Only allow superusers and admins.
        'allowed_roles': ['superuser', 'admin'],
        
        # Finally, let's add the schema definition for this endpoint.
        'schema': schema,
    }

Finally, a slight update to our authentication class is in order.

.. code-block:: python

    from eve import Eve
    from eve.auth import BasicAuth
    from werkzeug.security import check_password_hash


    class RolesAuth(BasicAuth):
        def check_auth(self, username, password, allowed_roles, resource):
            # use Eve's own db driver; no additional connections/resources are used
            accounts = app.data.driver.db['accounts']
            lookup = {'username': username}
            if allowed_roles:
                # only retrieve a user if his roles match ``allowed_roles``
                lookup['roles'] = {'$in': allowed_roles}
            account = accounts.find_one(lookup)
            return account and check_password_hash(account['password'], password)


    if __name__ == '__main__':
        app = Eve(auth=RolesAuth)
        app.run()

What the above snippet does is securing all API endpoints with role-base access
control. It is, in fact, the same snippet seen in :ref:`roleaccess`. This
tecnique allows us to keep the code untouched as we add more `superuser` or
`admin` accounts (and we'll probably be adding them by accessing our very own
API). Also, should the need arise, we could easily restrict access to more
endpoints just by updating the settings file, again without touching the
authentication class.

3. Securing other API endpoints
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This will be quick, as both the `hard-coding` and the `role-based` access
control approaches above effectively secure all API endpoints already.  Passing
the authentication class to the ``Eve`` object enables authentication for the
whole API: every time an endpoint is hit with a request, the class instance is
invoked.

Of course you can still fine-tuning security, for example by allowing public
access to certain endpoints, or to certain HTTP methods. See :ref:`auth` for
more details.

4. Only allowing access to account resources
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Most of the time when you allow Authenticated users to store data, you only
want them to access to their own data. This can be convenientely achieved by
using the :ref:`user-restricted` feature. When enabled, each stored document is
associated with the account that created it. This allows the API to transparently
serve only account-created documents on all kind of requests: read, edit, delete
and of course create.

The only thing that we need to do is configure the name of the field that will
be used to store the owner of the document. It can be done at a global level
(all endpoints will use the same field) and/or at resource level (see the
feature documentation for details). Let's just set the global field name in our
settings file:

.. code-block:: python

    AUTH_USERFIELD_NAME: 'username'

This is all we need to do. Now when a user hits the (say) ``/invoices/``
endpoint with a GET request, he will only be served with the invoices created
by his own account. The same will happen with DELETE and PATCH, making it
impossible for an authenticated user to accidentally delete or edit other
people data.  chance

.. _SSL/TLS: http://en.wikipedia.org/wiki/Transport_Layer_Security
